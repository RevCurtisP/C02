;c02 Program Initialization Code for Vic-20 - Common Code

;PETSCII Key Mappings
DELKEY  EQU $14   ;Delete/Backspace Key (Delete)
ESCKEY  EQU $03   ;Escape/Stop Key      (RUN/STOP)
RTNKEY  EQU $0D   ;Return/Enter Key     (RETURN)

;Zero Page Locations
SRCLO   EQU $22   ;Source Pointer LSB [Temporary Pointers]
SRCHI   EQU $23   ;Source Pointer MSB [Temporary Pointers]
DSTLO   EQU $24   ;Destination Pointer LSB [Temporary Pointers]
DSTHI   EQU $25   ;Destination Pointer MSB [Temporary Pointers]
BLKLO   EQU $26   ;Block Pointer LSB [Floating Point Work Area]
BLKHI   EQU $27   ;Block Pointer MSB [Floating Point Work Area]
STKLO   EQU $28   ;Stack Pointer LSB [Floating Point Work Area]
STKHI   EQU $29   ;Stack Pointer MSB [Floating Point Work Area]
RDSEED  EQU $2A   ;Random Seed [Software Jiffy Clock (Low Byte)]
TEMP0   EQU $FB   ;Temporary Variable [Unused Byte]
TEMP1   EQU $FC   ;Temporary Variable [Unused Byte]
TEMP2   EQU $FD   ;Temporary Variable [Unused Byte]
TEMP3   EQU $FE   ;Temporary Variable [Unused Byte]

USER0   EQU $0310 ;Free Byte for User Programs
RANDOM  EQU $0311 ;Random Number Storage [Unused Byte]
STKSAV  EQU $0312 ;Machine Stack Storage [Unused Byte]
STKSLO  EQU $0313 ;Stack Start LSB [Unused Byte]
STKSHI  EQU $0334 ;Stack Start MSB [Unused Byte]
STKELO  EQU $0335 ;Stack End LSB [Unused Byte]
STKEHI  EQU $0336 ;Stack End MSB [Unused Byte]
BLKSLO  EQU $0337 ;Block Start LSB [Unused Byte]
BLKSHI  EQU $0338 ;Block Start MSB [Unused Byte]
BLKELO  EQU $0339 ;Block Start MSB [Unused Byte]
BLKEHI  EQU $033A ;Block End MSB [Unused Byte]
BLKLEN  EQU $033B ;Block Length [Unused Byte]
TBFFR   EQU $033C ;Cassette I/O Buffer
USER12  EQU $03FC ;Free Byte for User Programs
USER13  EQU $03FD ;Free Byte for User Programs
USER14  EQU $03FE ;Free Byte for User Programs
USER15  EQU $03FF ;Free Byte for User Programs

START:  TSX         ;Get Stack Pointer
        STX STKSAV  ;and Save for Exit
        JMP MAIN    ;Execute Program

EXIT:   LDX STKSAV  ;Retrieve Saved Stack Pointer
        TXS         ;and Restore It
        RTS         ;Return to BASIC

;Poll Keyboard for Character
POLKEY  EQU $FFE4   ;Aliased to Kernal GETIN Routine

;Get Character from Keyboard
GETKEY: JSR POLKEY  ;Get Key From Keybord
        ;The below is not working...
        LDY $9005   ;Get Character Memory Offset
        CPY #242    ;If Upper/Lower
        BNE GETKEX
        BIT $FF     ;  Bit 7 -> C, Bit 6 -> V
        BVC GETKEX  ;  If Bit 6 Set (Alpha)
        BCC GETKEL  ;    If Bit 7 Set (PETSCII Upper)
        AND #$7F    ;      Clear Bit 7 (ASCII Upper)
        BNE GETKEX  ;    Else
GETKEL: ORA #$20    ;      Set Bit 5 (ASCII Lower)
GETKEX: ORA #$00    ;Set Flags
        RTS

;A = $41 %0100 0001
;a = $C1 %1100 0001 PETSCII
;a = $61 %0110 0001 PETSCII
;$9005 = 240 UPR/GFX
;        242 UPR/LWR

;Wait for Character from Keyboard
GETCHR: JSR GETKEY  ;Poll Keyboard
        BEQ GETCHR  ;If No Key, Loop
        RTS

;Print Character to Console
;uses direct call to SCRNOUT instead of CHROUT 
PUTCHR  EQU $E742  ;Aliased to SRCNOUT Routine

;Delete Previous Character
DELCHR: LDA #DELKEY ;Load Delete Character
        JMP PUTCHR  ;Print and Return

;Advance Character to Next line
NEWLIN: LDA #RTNKEY ;Load C/R into Accumulator
        JMP PUTCHR  ;Print and Return

;Clear the Screen
CLRSCR  EQU $E55F   ;Alias to CLSR Routine

;Move Cursor to Specified Coordinates
SETPOS: STA $D3     ;Save Cursor Column
        STY $D6     ;Save Cursor Row
        JMP $E587   ;Set Screen Poiners and Return

;Get Cursor Position
GETPOS: LDY $D6     ;Load Cursor Row
        LDA $D3     ;Load Cursor Column
        RTS

;Get Screen Size
GETSIZ: JSR $FFED   ;Call SCREEN Kernal Routine
        TXA         ;Transfer Width to Accumulator
        RTS

;Print Byte as Two-Digit Hex Number to Console
PRBYTE: PHA         ;Save Accumulater
        LSR         ;Shift Hi Nybble to Low Nybble
        LSR 
        LSR 
        LSR 
        JSR PRHEX   ;  and Print it
        PLA         ;Restore Accumulator 
                    ;  and fall into prhex

;Print Low Nybble as Hex Digit to Console
PRHEX:  AND #$0F    ;Strip High Nybble
        CMP #$0A    ;If Low Nybble >= 10
        BCC PRHEXC  ;  
        ADC #$06    ;  Convert ':' to 'A'...
PRHEXC: ADC #$30    ;Convert to ASCII Character
        JMP PUTCHR  ;Print Hex Digit and Return
