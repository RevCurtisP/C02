; C02 library stdiox.h02 assembly language subroutines

ANYKEP: DC  "Press any key to continue...",0

ANYKEY: JSR NEWLIN      ;Start at Beginning of Next Line
        LDY #>ANYKEP     ;Load Prompt High Byte
        LDX #<ANYKEP     ;Load Prompt Low Byte
                        ;Drop into GETCPR

;Display Prompt and Wait for Character
GETCPR: JSR PUTLN       ;Print Prompt
        JSR NEWLIN      ;Generate Blank Line
        JMP GETC        ;Wait for and Return Keypress

;Print Byte as Left Justified Decimal Number
;void putdel(b)
;Args: A = number to print
;Sets: TEMP0 - ones digit
;      TEMP1 - tens digit
;      TEMP2 - hundreds digit
;      TEMP3 - number that was printed
;putdem - Alternate Entry Point if number is already in TEMP3
;putdeh - Alternate Entry Point to print only padding spaces
PUTDEL: STA TEMP3
PUTDEM: JSR PUTDEC      ;Print Decimal Representation of number
        LDA TEMP3       ;
PUTDEH: CMP #100        ;If Number < 100
        BCS PUTDET      ;
        JSR PUTSPC      ;  Print a Space
        LDA TEMP3       ;
PUTDET: CMP #10         ;  If Number < 10  
        BCS PUTDEX      ;
        JSR PUTSPC      ;    Print another Space
PUTDEX: RTS

;Print Byte as Right Justified Decimal Number
;void putder(b)
;Args: A = number to print
;Sets: TEMP0 - ones digit
;      TEMP1 - tens digit
;      TEMP2 - hundreds digit
;      TEMP3 - number that was printed
PUTDER: STA TEMP3
PUTDES: JSR PUTDEH
        LDA TEMP3

;Print Byte as Decimal Number
;void putdec(b)
;Args: A = number to print
;Sets: TEMP0 - ones digit
;      TEMP1 - tens digit
;      TEMP2 - hundreds digit
PUTDEC: JSR CUBCD       ;Convert Accumulator to Unpacked BCD
        LDA TEMP2       ;Get High Byte
        BEQ PUTDE1      ;If Not Zero
        JSR PUTDEP      ;  Convert Low Nybble
PUTDE1: LDA TEMP1       ;Get Low Byte
        BNE PUTDE2      ;If Not Zero
        CMP TEMP2       ;  and Hundreds 
        BEQ PUTDE3      ;  not Zero   
PUTDE2: JSR PUTDEP      ;  Convert It
PUTDE3: LDA TEMP0       ;Get Low Byte
PUTDEP: ORA #$30        ;Convert to ASCII digit
        JSR PRCHR       ;And Print
        RTS

;Print a Space
PUTSPC: LDA #32         ;Load Space Character
        JMP PRCHR       ;and Print it

;Print Byte in Formatted String
;void printf(b, &s)
;Args: A = number to format
;      Y,X = address of formatting string
;Sets: TEMP3 - number to format
PRINTF: JSR SETSRC      ;Initialize Source String
        STA TEMP3       ;Save Byte to Format
PRINTL: LDA (SRCLO),Y   ;Read next character in string
        BEQ PRINTX      ;If Not 0
        CMP #'%         ;'  If Format Specified 
        BEQ PRINTP      ;    Jump to Formatter
PRINTC: JSR PRCHR       ;  Print character at offset,
PRINTY: INY             ;  increment offset, and
        BPL PRINTL      ;  loop if less than 128
PRINTX: RTS             ;  characters printed
;Process Format Specifier
PRINTP: INY             ;Increment Offset
        LDA (SRCLO),Y   ;Get Formatting Character
        BEQ PRINTX      ;If NUL, then Exit
        CMP #'%         ;'If Percent Sign 
        BEQ PRINTC      ;  Print it and Continue
        AND #$DF        ;Convert to Upper Case
        CMP #'L         ;'If "l" or "L" 
        BNE PRINTR
        LDA TEMP3       ;  Load Byte to Format
        JSR PUTDEM      ;  Print Left Justified
        JMP PRINTY      ;  and Continue Printing Screen
PRINTR: CMP #'R         ;'If "r" or "R" 
        BNE PRINTD
        LDA TEMP3       ;  Load Byte to Format
        JSR PUTDES      ;  Print Right Justified
        JMP PRINTY      ;  and Continue Printing Screen
PRINTD: CMP #'D         ;'Else If "d" or "D" 
        BNE PRINTH
        LDA TEMP3       ;  Load Byte to Format
        JSR PUTDEC      ;  Print as Decimal
        JMP PRINTY      ;  and Continue Printing Screen
PRINTH: CMP #'H         ;'Else If "h" or "H" 
        BNE PRINTS
        LDA TEMP3       ;  Load Byte to Format
        JSR PRBYTE      ;  Print as Hexadecimal
        JMP PRINTY      ;  and Continue Printing Screen
PRINTS: CMP #'S         ;'Else If "s" or "s" 
        BNE PRINTB
        STY TEMP0       ;  Save Index
        JSR PUTDST      ;  Print Destination String
        LDY TEMP0       ;  Restore Index
        JMP PRINTY      ;
PRINTB: LDA TEMP3       ;Else
        JMP PRINTC      ;  Print Raw Byte and Continue

                       ;and fall into putsub
;char putdst()
PUTDST: LDY #0         ;Initialize character offset
PUTDSL: LDA (DSTLO),Y  ;Read next character in string
        BEQ PUTDSX     ;If Not 0
        JSR PUTC       ;  Print character at offset,
        INY            ;  increment offset, and
        BPL PUTDSL     ;  loop if less than 128
PUTDSX: TYA            ;Return number of
        RTS            ;  characters printed
